# Trade Journal Application - Cursor Rules

## Project Overview
This is a comprehensive trading journal application built with Next.js 14, TypeScript, SQLite, and Prisma. The application helps traders track, analyze, and improve their trading performance across equity, futures, and options markets.

## Tech Stack
- **Framework:** Next.js 14 with App Router
- **Language:** TypeScript
- **Database:** SQLite with Prisma ORM
- **Styling:** Tailwind CSS + shadcn/ui components
- **Charts:** Recharts for analytics
- **Authentication:** None (personal use only)
- **Deployment:** Vercel

## Project Structure
```
src/
├── app/                    # Next.js App Router pages
├── components/            # Reusable UI components
│   ├── ui/               # shadcn/ui components
│   ├── forms/            # Form components
│   ├── charts/           # Chart components
│   └── layout/           # Layout components
├── lib/                  # Utility functions and configurations
├── types/                # TypeScript type definitions
├── hooks/                # Custom React hooks
├── services/             # Business logic and API services
├── utils/                # Helper functions
└── data/                 # Database schemas and migrations
```

## Development Guidelines

### Package Management
- **NEVER update package.json directly** - Always use npm CLI commands
- Use `npm install <package-name>` to add new dependencies
- Use `npm install <package-name>@<version>` for specific versions
- Use `npm install -D <package-name>` for dev dependencies
- Use `npm uninstall <package-name>` to remove packages
- Use `npm update` to update existing packages
- Always commit package-lock.json with package.json changes

### Code Style
- Use TypeScript strict mode
- Follow Next.js 14 App Router conventions
- Use functional components with hooks
- Implement proper error boundaries
- Use Tailwind CSS for styling
- Follow shadcn/ui component patterns

### Component Guidelines

### Modern Component Architecture
- Create reusable, composable components
- Use proper TypeScript interfaces
- Implement proper accessibility (WCAG AA)
- Add loading states and error handling
- Use proper form validation with react-hook-form
- Implement responsive design (mobile-first)

### Modern Component Patterns
- **Compound Components**: Build complex components from smaller, composable parts
- **Render Props**: Use render props for flexible component composition
- **Custom Hooks**: Extract logic into reusable custom hooks
- **Higher-Order Components**: Create HOCs for cross-cutting concerns
- **Context Providers**: Use React Context for global state management
- **Error Boundaries**: Implement error boundaries for graceful error handling

### Component Design Principles
- **Single Responsibility**: Each component should have one clear purpose
- **Composition over Inheritance**: Favor composition patterns
- **Props Interface**: Always define clear TypeScript interfaces
- **Default Props**: Provide sensible defaults for optional props
- **Forward Refs**: Use forwardRef for components that need ref access
- **Memoization**: Use React.memo for performance optimization

### Modern Styling Patterns
```typescript
// Use CSS-in-JS with Tailwind
const ModernCard = ({ children, variant = 'default' }: CardProps) => {
  return (
    <div className={cn(
      'rounded-xl border bg-card text-card-foreground shadow-sm',
      'transition-all duration-200 hover:shadow-md',
      'backdrop-blur-sm bg-white/80 dark:bg-gray-900/80',
      {
        'border-green-200 bg-green-50/50': variant === 'success',
        'border-red-200 bg-red-50/50': variant === 'error',
        'border-blue-200 bg-blue-50/50': variant === 'info'
      }
    )}>
      {children}
    </div>
  )
}
```

### Animation Integration
```typescript
// Use Framer Motion for animations
import { motion, AnimatePresence } from 'framer-motion'

const AnimatedCard = ({ isVisible, children }) => (
  <AnimatePresence>
    {isVisible && (
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
        transition={{ duration: 0.3, ease: 'easeOut' }}
        className="rounded-lg border p-4"
      >
        {children}
      </motion.div>
    )}
  </AnimatePresence>
)
```

### Database Guidelines
- Use Prisma for all database operations
- Create proper relationships between tables
- Implement proper indexing for performance
- Use transactions for complex operations
- Add proper validation at database level
- Follow SQLite best practices

### Trading-Specific Requirements
- All monetary values in INR (₹)
- Support Equity, Futures, and Options trading
- Implement accurate charge calculations (STT, Exchange, SEBI, Stamp Duty)
- Real-time P&L calculations
- Support multiple strategy tags and emotional states
- Handle complex options trading (strike, expiry, lot size)

## Key Features to Implement

### 1. Trade Recording Module
- Multi-step form for trade entry
- Real-time charge calculation engine
- Support for all instrument types
- File upload for trade attachments
- Draft saving functionality

### 2. Analytics Dashboard
- Performance summary widgets
- Risk metrics and drawdown analysis
- Time-based performance charts
- Strategy performance analysis
- Behavioral insights

### 3. Portfolio Management
- Real-time position tracking
- Portfolio allocation charts
- Risk metrics and concentration analysis
- Position management actions

### 4. Reports & Export
- Multiple export formats (CSV, Excel, PDF)
- Custom report builder
- Scheduled reports
- Data backup and restore

## Code Patterns

### API Routes
```typescript
// app/api/trades/route.ts
export async function GET(request: Request) {
  // Handle GET requests
}

export async function POST(request: Request) {
  // Handle POST requests
}
```

### Database Operations
```typescript
// Use Prisma client
import { prisma } from '@/lib/prisma'

const trades = await prisma.trade.findMany({
  where: { userId: user.id },
  include: { charges: true, tags: true }
})
```

### Component Structure
```typescript
interface ComponentProps {
  // Define props interface
}

export function Component({ ...props }: ComponentProps) {
  // Component implementation
}
```

### Form Handling
```typescript
// Use react-hook-form with zod validation
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { z } from 'zod'

const schema = z.object({
  // Define validation schema
})
```

## File Naming Conventions
- Components: PascalCase (e.g., `TradeForm.tsx`)
- Hooks: camelCase starting with 'use' (e.g., `useTradeData.ts`)
- Utilities: camelCase (e.g., `calculateCharges.ts`)
- Types: PascalCase (e.g., `TradeTypes.ts`)
- API routes: lowercase (e.g., `trades/route.ts`)

## Import Organization
```typescript
// 1. React imports
import React from 'react'
import { useState, useEffect } from 'react'

// 2. Next.js imports
import { NextRequest, NextResponse } from 'next/server'

// 3. Third-party imports
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'

// 4. Internal imports
import { Button } from '@/components/ui/button'
import { calculateCharges } from '@/utils/calculations'
import { Trade } from '@/types/trade'
```

## Error Handling
- Use try-catch blocks for async operations
- Implement proper error boundaries
- Show user-friendly error messages
- Log errors for debugging
- Handle network errors gracefully

## Performance Guidelines

### React Performance
- Use React.memo for expensive components
- Implement proper loading states
- Use pagination for large datasets
- Optimize database queries
- Implement proper caching strategies

### Modern Performance Patterns
- **Code Splitting**: Use dynamic imports for route-based code splitting
- **Lazy Loading**: Implement lazy loading for images and components
- **Virtual Scrolling**: Use virtual scrolling for large lists
- **Debouncing**: Implement debouncing for search and input handlers
- **Throttling**: Use throttling for scroll and resize events
- **Memoization**: Use useMemo and useCallback for expensive calculations

### Bundle Optimization
```typescript
// Dynamic imports for code splitting
const TradeForm = dynamic(() => import('@/components/forms/TradeForm'), {
  loading: () => <TradeFormSkeleton />,
  ssr: false
})

// Lazy loading with Suspense
const AnalyticsDashboard = lazy(() => import('@/components/AnalyticsDashboard'))

// Memoized expensive calculations
const MemoizedChart = memo(({ data }: ChartProps) => {
  const processedData = useMemo(() => 
    processChartData(data), [data]
  )
  
  return <Chart data={processedData} />
})
```

### Database Performance
- Use proper indexing for frequently queried fields
- Implement database connection pooling
- Use database views for complex queries
- Implement query result caching
- Use database transactions efficiently
- Monitor and optimize slow queries

### Caching Strategies
```typescript
// SWR for data fetching with caching
const { data, error, isLoading } = useSWR(
  '/api/trades',
  fetcher,
  {
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    dedupingInterval: 60000, // 1 minute
    errorRetryCount: 3
  }
)

// React Query for server state management
const { data: trades } = useQuery({
  queryKey: ['trades', filters],
  queryFn: () => fetchTrades(filters),
  staleTime: 5 * 60 * 1000, // 5 minutes
  cacheTime: 10 * 60 * 1000, // 10 minutes
})
```

## Security Guidelines
- Validate all inputs
- Sanitize user data
- Use proper SQL injection prevention
- Implement rate limiting
- Handle sensitive data properly

## Testing Requirements
- Write unit tests for utilities
- Test components with React Testing Library
- Test API routes
- Implement E2E tests with Playwright
- Maintain >90% test coverage

## Accessibility Requirements
- Use semantic HTML
- Implement proper ARIA labels
- Ensure keyboard navigation
- Maintain color contrast ratios
- Add screen reader support

## Trading-Specific Calculations

### Charge Calculations
```typescript
// STT: 0.1% on sell value
const stt = sellValue * 0.001

// Exchange: 0.00173% on turnover
const exchange = turnover * 0.0000173

// SEBI: 0.0001% on turnover
const sebi = turnover * 0.000001

// Stamp Duty: 0.003% on turnover
const stampDuty = turnover * 0.00003
```

### P&L Calculations
```typescript
// Gross P&L
const grossPnl = exitValue - entryValue

// Net P&L
const netPnl = grossPnl - totalCharges

// Percentage Return
const percentageReturn = (netPnl / entryValue) * 100
```

## Common Patterns

### Data Fetching
```typescript
// Use SWR or React Query for data fetching
import useSWR from 'swr'

const { data, error, isLoading } = useSWR('/api/trades', fetcher)
```

### State Management
```typescript
// Use React Context for global state
const TradeContext = createContext<TradeContextType | undefined>(undefined)
```

### Form Validation
```typescript
// Use Zod for schema validation
const tradeSchema = z.object({
  symbol: z.string().min(1, 'Symbol is required'),
  quantity: z.number().positive('Quantity must be positive'),
  entryPrice: z.number().positive('Entry price must be positive')
})
```

## Database Schema Guidelines
- Use proper foreign key relationships
- Implement soft deletes where needed
- Add proper indexes for performance
- Use enums for fixed values
- Implement audit trails

## UI/UX Guidelines

### Modern Design Principles
- Follow the detailed PRD specifications
- Use consistent spacing and typography
- Implement proper loading states
- Add smooth animations and transitions
- Ensure mobile responsiveness
- Use proper color coding for P&L (green/red)

### Modern UI Patterns
- **Glassmorphism**: Use subtle backdrop blur effects for modals and cards
- **Neumorphism**: Apply soft shadows and highlights for depth
- **Micro-interactions**: Add hover effects, button press animations, and state transitions
- **Skeleton Loading**: Use skeleton screens instead of spinners for better UX
- **Progressive Disclosure**: Show information in layers with expand/collapse patterns
- **Floating Action Buttons**: Use FABs for primary actions
- **Card-based Layout**: Organize content in clean, bordered cards
- **Dark Mode Support**: Implement theme switching with smooth transitions

### Visual Hierarchy
- Use consistent typography scale (12px, 14px, 16px, 18px, 24px, 32px, 48px)
- Apply proper contrast ratios (4.5:1 minimum)
- Use color psychology (green for profit, red for loss, blue for neutral)
- Implement proper spacing system (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Create visual flow with proper alignment and grouping

### Modern Components
- **Data Tables**: Use modern table designs with sticky headers, row selection, and sorting
- **Charts**: Implement interactive charts with tooltips, zoom, and pan
- **Forms**: Use floating labels, real-time validation, and smart defaults
- **Navigation**: Implement sidebar with collapsible sections and breadcrumbs
- **Modals**: Use slide-up modals on mobile, centered on desktop
- **Toast Notifications**: Add non-intrusive success/error messages
- **Progress Indicators**: Show progress for long operations
- **Empty States**: Design engaging empty states with illustrations

### Animation Guidelines
- Use CSS transitions for micro-interactions (200-300ms)
- Implement spring animations for natural feel
- Add loading animations for better perceived performance
- Use staggered animations for list items
- Implement page transition animations
- Add scroll-triggered animations for engagement

### Color System
```css
/* Primary Colors */
--primary: 220 14% 96%     /* Light mode background */
--primary-foreground: 220 9% 46%  /* Light mode text */

/* Accent Colors */
--accent: 142 76% 36%      /* Success/Profit green */
--accent-foreground: 355 7% 97%   /* Success text */

/* Destructive Colors */
--destructive: 0 84% 60%   /* Error/Loss red */
--destructive-foreground: 0 0% 98% /* Error text */

/* Trading Specific */
--profit: 142 76% 36%      /* Profit green */
--loss: 0 84% 60%          /* Loss red */
--neutral: 220 9% 46%      /* Neutral gray */
```

### Typography Scale
```css
/* Trading App Typography */
--text-xs: 0.75rem;      /* 12px - Small labels */
--text-sm: 0.875rem;     /* 14px - Body text */
--text-base: 1rem;       /* 16px - Default text */
--text-lg: 1.125rem;     /* 18px - Large text */
--text-xl: 1.25rem;      /* 20px - Headings */
--text-2xl: 1.5rem;      /* 24px - Section headers */
--text-3xl: 1.875rem;    /* 30px - Page titles */
--text-4xl: 2.25rem;     /* 36px - Hero text */
```

### Spacing System
```css
/* Consistent spacing scale */
--space-1: 0.25rem;      /* 4px */
--space-2: 0.5rem;       /* 8px */
--space-3: 0.75rem;      /* 12px */
--space-4: 1rem;         /* 16px */
--space-5: 1.25rem;      /* 20px */
--space-6: 1.5rem;       /* 24px */
--space-8: 2rem;         /* 32px */
--space-10: 2.5rem;      /* 40px */
--space-12: 3rem;        /* 48px */
--space-16: 4rem;        /* 64px */
```

### Modern UI Libraries Integration
- **shadcn/ui**: Use as base component library
- **Framer Motion**: For advanced animations
- **React Spring**: For physics-based animations
- **React Hook Form**: For form management
- **Zod**: For validation schemas
- **Recharts**: For data visualization
- **React Hot Toast**: For notifications

## Deployment Guidelines
- Use Vercel for deployment
- Configure environment variables properly
- Set up proper database migrations
- Implement proper error monitoring
- Use proper logging

## Code Review Checklist
- [ ] TypeScript types are properly defined
- [ ] Components are reusable and composable
- [ ] Error handling is implemented
- [ ] Accessibility requirements are met
- [ ] Performance is optimized
- [ ] Tests are written and passing
- [ ] Code follows project conventions
- [ ] Trading calculations are accurate
- [ ] Mobile responsiveness is verified
- [ ] Package.json was updated using npm CLI (not manually)
- [ ] Package-lock.json is committed with changes

## Modern UI Implementation Examples

### Trading Dashboard Layout
```typescript
// Modern dashboard with glassmorphism
const TradingDashboard = () => {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 dark:from-slate-900 dark:to-slate-800">
      <div className="container mx-auto p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          {metrics.map((metric, index) => (
            <motion.div
              key={metric.id}
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: index * 0.1 }}
              className="backdrop-blur-sm bg-white/80 dark:bg-gray-800/80 rounded-2xl p-6 shadow-lg border border-white/20"
            >
              <MetricCard {...metric} />
            </motion.div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

### Modern Trade Form
```typescript
// Animated multi-step form
const TradeForm = () => {
  const [currentStep, setCurrentStep] = useState(0)
  
  return (
    <div className="max-w-4xl mx-auto">
      <div className="backdrop-blur-sm bg-white/90 dark:bg-gray-900/90 rounded-2xl shadow-2xl border border-white/20">
        <div className="p-8">
          <StepIndicator currentStep={currentStep} totalSteps={4} />
          <AnimatePresence mode="wait">
            <motion.div
              key={currentStep}
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -20 }}
              transition={{ duration: 0.3 }}
            >
              {renderStep(currentStep)}
            </motion.div>
          </AnimatePresence>
        </div>
      </div>
    </div>
  )
}
```

### Modern Data Table
```typescript
// Interactive data table with modern styling
const TradesTable = ({ data }: { data: Trade[] }) => {
  return (
    <div className="backdrop-blur-sm bg-white/80 dark:bg-gray-800/80 rounded-xl shadow-lg border border-white/20 overflow-hidden">
      <div className="overflow-x-auto">
        <table className="w-full">
          <thead className="bg-gradient-to-r from-slate-50 to-slate-100 dark:from-gray-800 dark:to-gray-700">
            <tr>
              {columns.map((column) => (
                <th key={column.key} className="px-6 py-4 text-left font-semibold">
                  {column.label}
                </th>
              ))}
            </tr>
          </thead>
          <tbody>
            {data.map((trade, index) => (
              <motion.tr
                key={trade.id}
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: index * 0.05 }}
                className="border-b border-gray-200/50 hover:bg-gray-50/50 dark:hover:bg-gray-700/50 transition-colors"
              >
                <TradeRow trade={trade} />
              </motion.tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

## Notes
- This is a personal trading journal application
- No authentication system needed
- Focus on accuracy of trading calculations
- Prioritize user experience and performance
- Follow the detailed PRD requirements
- Maintain code quality and documentation
- Implement modern UI patterns for better user engagement
- Use glassmorphism and neumorphism for visual appeal
- Add micro-interactions for enhanced user experience
